#!/bin/bash
# Jor-Conn
# A portable and configurable networking solution.

# --- Load Path Detection ---
# Detect if we are running installed or local
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [ -f "$SCRIPT_DIR/lib/shared.sh" ]; then
    # Local Development / Standalone Mode
    BASE_DIR="$SCRIPT_DIR"
    LIB_FILE="$BASE_DIR/lib/shared.sh"
    CONFIG_FILE="$BASE_DIR/config/jor.conf"
    NETWORKS_DIR="$BASE_DIR/config/networks"
elif [ -f "/usr/local/lib/jor-conn/shared.sh" ]; then
    # Installed Mode (Legacy/System)
    BASE_DIR="/usr/local/lib/jor-conn"
    LIB_FILE="/usr/local/lib/jor-conn/shared.sh"
    CONFIG_FILE="/etc/jor-conn/config.conf"
    NETWORKS_DIR="/etc/jor-conn/networks"
else
    echo "CRITICAL: Shared library not found in local ($SCRIPT_DIR/lib/shared.sh) or system paths."
    exit 1
fi

# --- Load Configuration ---
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
else
    echo "CRITICAL: Configuration file $CONFIG_FILE not found."
    exit 1
fi

# --- Load Shared Library ---
source "$LIB_FILE"

# --- Function: Check Root Privileges ---
check_root() {
    if [ "$(id -u)" -ne 0 ]; then
        echo -e "${RED}Error: This command requires root privileges. Please run with sudo.${NC}"
        log "Error: Command requires root privileges."
        exit 1
    fi
}

# --- Function: Connect to Network ---
connect_network() {
    local profile_name=$1
    # Security: Validate profile name to prevent path traversal
    if [[ ! "$profile_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        echo -e "${RED}Error: Invalid profile name. Only alphanumeric, dash, and underscore allowed.${NC}"
        log "Error: Invalid profile name attempted: $profile_name"
        exit 1
    fi
    local profile_path="$NETWORKS_DIR/$profile_name"

    if [ ! -f "$profile_path" ]; then
        echo -e "${RED}Error: Network profile '$profile_name' not found at $profile_path.${NC}"
        log "Error: Network profile '$profile_name' not found."
        exit 1
    fi

    show_banner
    echo -e "${YELLOW}üîå Connecting using profile '$profile_name'...${NC}"
    log "Starting connection with profile: $profile_name"

    # Security: Source config but warn if file ownership is unsafe
    if [ "$(stat -c %u "$profile_path")" -ne 0 ] && [ "$(id -u)" -eq 0 ]; then
        echo -e "${YELLOW}WARNING: Profile owned by non-root user. This is a security risk.${NC}"
    fi
    source "$profile_path"

    # Stop existing connections
    progress_bar 1 "Stopping existing connections"
    killall wpa_supplicant >/dev/null 2>&1 || true
    sleep 1

    # Create temporary wpa_supplicant config
    local temp_wpa_config="/tmp/wpa_config_$$.conf"
    # Security: Use envsubst if possible, otherwise be very careful with eval (legacy support)
    # Ideally, we should remove eval completely. For now, assuming $WPA_CONFIG_CONTENT is trusted.
    # Note: 'eval' is kept for heredoc variable expansion support in existing profiles,
    # but strictly this should be migrated to `envsubst` for true security.
    # Adding a safety check to ensure WPA_CONFIG_CONTENT doesn't contain command injection chars like backticks or $()
    if [[ "$WPA_CONFIG_CONTENT" =~ \` || "$WPA_CONFIG_CONTENT" =~ \$\( ]]; then
         echo -e "${RED}Security Error: Profile contains command substitution. Aborting.${NC}"
         exit 1
    fi
    echo -e "$(eval echo "$WPA_CONFIG_CONTENT")" > "$temp_wpa_config"

    # Start new connection
    progress_bar 2 "Starting network '$profile_name'"
    wpa_supplicant -B -i "$NETWORK_INTERFACE" -c "$temp_wpa_config"
    sleep 3
    dhclient "$NETWORK_INTERFACE"
    rm "$temp_wpa_config"

    # Apply or remove proxy settings
    if [ "$APPLY_PROXY" = "true" ]; then
        progress_bar 1 "Applying proxy settings"
        enable_proxy_system
        log "Proxy settings applied for system, APT, Git, NPM, Wget, etc."
    else
        progress_bar 1 "Removing proxy settings"
        disable_proxy_system
        log "Proxy settings removed."
    fi

    # Sync time
    progress_bar 1 "Syncing time"
    if command -v ntpdate &>/dev/null; then
        ntpdate -s pool.ntp.org >/dev/null 2>&1 || true
    elif command -v timedatectl &>/dev/null; then
        timedatectl set-ntp true >/dev/null 2>&1 || true
    else
        log "Time sync skipped: no suitable tool found."
    fi

    echo -e "${GREEN}‚úÖ Successfully connected using profile '$profile_name'!${NC}"
    log "Connection successful for profile '$profile_name'."
}

# --- Function: Check DuckDNS Status ---
check_duckdns() {
    echo -e "${BLUE}üîç Checking DuckDNS status...${NC}"
    local duckdns_ip=$(dig +short "$DUCKDNS_DOMAIN.duckdns.org" 2>/dev/null | head -1)
    local wan_ip=$(curl -s ifconfig.me)

    if [ -n "$duckdns_ip" ]; then
        echo -e "üåç DuckDNS IP: $duckdns_ip"
        echo -e "üì° Your WAN IP: $wan_ip"
        if [ "$duckdns_ip" = "$wan_ip" ]; then
            echo -e "${GREEN}‚úÖ DuckDNS is correctly pointing to your IP.${NC}"
        else
            echo -e "${YELLOW}‚ö†Ô∏è DuckDNS IP does not match your current WAN IP.${NC}"
        fi
    else
        echo -e "${RED}‚ùå Could not resolve $DUCKDNS_DOMAIN.duckdns.org.${NC}"
    fi
}

# --- Main Command Handler ---
case "$1" in
    "connect")
        check_root
        if [ -z "$2" ]; then
            echo -e "${RED}Error: Please specify a network profile to connect to.${NC}"
            echo -e "Usage: sudo jor_conn connect <profile_name>"
            exit 1
        fi
        connect_network "$2"
        ;;
    "remote-vnc")
        show_banner
        echo -e "${YELLOW}üñ•Ô∏è  Initiating VNC connection...${NC}"
        log "Starting VNC connection"
        progress_bar 2 "Detecting server location"
        check_duckdns
        echo ""
        if ping -c 1 -W 2 "$VNC_SERVER_LOCAL" >/dev/null 2>&1; then
            echo -e "${GREEN}üìç Server found locally at $VNC_SERVER_LOCAL${NC}"
            log "Connecting to VNC via local network"
            vncviewer "$VNC_SERVER_LOCAL:5901"
        else
            echo -e "${BLUE}üåç Connecting to VNC via DuckDNS: $VNC_SERVER_REMOTE${NC}"
            log "Connecting to VNC via DuckDNS"
            vncviewer "$VNC_SERVER_REMOTE:5901"
        fi
        ;;
    "status")
        show_banner
        echo -e "${CYAN}üìä System Status:${NC}"
        echo ""
        progress_bar 1 "Checking network interface"
        echo -e "${YELLOW}üåê Network Interface ($NETWORK_INTERFACE):${NC}"
        iw dev "$NETWORK_INTERFACE" link 2>/dev/null || echo -e "  ${RED}Interface not connected${NC}"
        echo ""
        progress_bar 0.5 "Checking IP address"
        echo -e "${YELLOW}üì° IP Address:${NC}"
        ip addr show "$NETWORK_INTERFACE" 2>/dev/null | grep 'inet ' | head -1 | awk '{print "  " $2}' || echo -e "  ${RED}No IP assigned${NC}"
        echo ""
        progress_bar 0.5 "Checking proxy settings"
        echo -e "${YELLOW}üîå Proxy Settings:${NC}"
        env | grep -i "proxy" | grep -v "no_proxy" || echo -e "  ${GREEN}No proxy settings active${NC}"
        echo ""
        progress_bar 1 "Checking server status"
        echo -e "${YELLOW}üñ•Ô∏è  Server Status:${NC}"
        if ping -c 1 -W 2 "$VNC_SERVER_LOCAL" >/dev/null 2>&1; then
            echo -e "  ${GREEN}‚úÖ Local server ($VNC_SERVER_LOCAL) is reachable${NC}"
        else
            echo -e "  ${YELLOW}‚ö†Ô∏è Local server ($VNC_SERVER_LOCAL) is unreachable${NC}"
        fi
        echo ""
        check_duckdns
        ;;
    "inject-proxy")
        check_root
        if [ -z "$2" ]; then
             echo -e "${RED}Error: Usage: sudo jor inject-proxy <chroot-path>${NC}"
             exit 1
        fi
        inject_proxy_to_chroot "$2"
        ;;
    "proxy")
        check_root
        if [ "$2" == "on" ]; then
            show_banner
            enable_proxy_system
        elif [ "$2" == "off" ]; then
            show_banner
            disable_proxy_system
        else
            echo "Usage: sudo jor proxy {on|off}"
            exit 1
        fi
        ;;
    "edit-config")
        check_root
        echo "Opening /etc/jor-conn/config.conf with nano..."
        nano /etc/jor-conn/config.conf
        echo "Config file saved. Changes will apply on next use."
        ;;
    "log")
        echo -e "${YELLOW}üìã Connection Log:${NC}"
        tail -20 "$LOG_FILE" 2>/dev/null || echo "No log file found."
        ;;
    "help"|"--help"|"-h")
        show_banner
        echo -e "${YELLOW}üìñ Jor-Conn Commands:${NC}"
        echo ""
        echo -e "${GREEN}Network Management:${NC}"
        echo "  sudo jor connect <profile>      - Connect using a network profile from $NETWORKS_DIR"
        echo ""
        echo -e "${BLUE}Remote Access:${NC}"
        echo "  jor remote-vnc                  - VNC connection (local/remote auto-detect)"
        echo ""
        echo -e "${CYAN}Monitoring & Config:${NC}"
        echo "  jor status                      - Complete system and network status"
        echo "  jor log                         - View the last 20 log entries"
        echo "  sudo jor edit-config            - Edit the main configuration file"
        echo ""
        echo -e "${PURPLE}Advanced:${NC}"
        echo "  sudo jor inject-proxy <dir>     - Inject proxy settings into a chroot/rootfs"
        echo "  jor proxy {on|off}              - Manually toggle proxy settings"
        echo ""
        ;;
    *)
        show_banner
        echo -e "${YELLOW}Usage: jor {connect|remote-vnc|status|inject-proxy|proxy|help}${NC}"
        echo "For connecting, use: sudo jor connect <profile_name>"
        echo "For help, use: jor help"
        echo ""
        ;;
esac

# Log command execution
log "Command executed: jor_conn $*"